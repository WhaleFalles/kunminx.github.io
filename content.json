{"pages":[],"posts":[{"title":"Android：Viabus - 年轻人的第一款架构","text":"前言你还在等那个，手把手带你重构的人出现吗？ 你是否经常听同事自嘲，“开始还想好好写，不知怎滴，后面越写越烂”？ 你知道为什么，“代码解耦” 福特最有话语权吗？ 在经历 5840 小时的探索和践行，某自主设计的架构已成功应用于公司商业级产品。就在前不久，5 天内完成 60 个类的核心模块的重构，以支持未来对全国 100 个乡镇地区的功能定制需求。（不要慌，架构已在 GitHub 开源，文末链接给出，而你只需 1 分钟时间，就能掌握该架构的使用。） 什么是 ViaBus⭐ ViaBus 是一款响应式架构，消息驱动编程。通过 bus 转发数据的请求和响应，实现 UI 和 业务 的完全解耦。 为什么选择 ViaBus 1 分钟即可掌握，ViaBus 的构造与使用方式。💡 当下就可使用，对原项目架构完全兼容，即插即用。🔥 允许以 业务或模块为单位，每天1小时，完成渐进式重构。💧 职责边界明确，无论是写 UI 还是业务，不再被打断、相互不拖累。🌱 原生接口即可实现 跨 Activity、跨组件的 实时双向通信。⚡ 无编译时注解，基于 Viabus 编写的组件可在任何项目中直接使用。🌎 更少的重复工作，扁平的交互模式，代码复用率提升至100%。💪… 更多依据详见 wiki - Android 四大架构的优缺点，你真的了解吗？ 如何使用 ViaBus在模块的 build.gradle 添加如下依赖1implementation &quot;com.kunminx.viabus:viabus-architecture:0.4.8&quot; 使用方法详见 wiki - 1分钟掌握 ViaBus 架构的使用 开源地址GitHub：KunMinX/android-viabus-architecture 更多访问Android：你还在等那个，手把手带你重构的人出现吗？","link":"/2018/09/25/Android：Viabus - 年轻人的第一款架构/"},{"title":"Android：1分钟掌握 ViaBus 架构的使用","text":"0. 在模块的 build.gradle 添加如下依赖1implementation &quot;com.kunminx.viabus:viabus-architecture:0.4.3&quot; 1. 定义接口，用于发送请求。 接口须继承于 IRequest，如：12345678public interface INoteRequest extends IRequest{ void queryList(); void insert(NoteBean bean); ...} 2. 定义 bus，用于支持请求接口的访问。 bus 须继承于BaseBus，如：12345678public class NoteBus extends BaseBus { public static INoteRequest note() { return (INoteRequest) getRequest(INoteRequest.class); } ...} 3. 将 ui 注册成为响应接收者。 在 ui 中，通过 bus 发送数据请求。并在 onResult 中，依据响应码实现 ui 逻辑的处理。12345678910111213141516171819202122232425262728293031323334353637public class NoteListFragment extends Fragment implements IResponse { @Override public void onCreate(@Nullable Bundle savedInstanceState) { ... NoteBus.registerResponseObserver(this); } @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) { ... NoteBus.note().queryList(); } @Override public void onResult(Result testResult) { String resultCode = (String) testResult.getResultCode(); switch (resultCode) { case NoteResultCode.QUERY_LIST: if (testResult.getResultObject() != null) { mAdapter.setList((List&lt;NoteBean&gt;) testResult.getResultObject()); mAdapter.notifyDataSetChanged(); } break; case NoteResultCode.INSERTED: ... } } @Override public void onDestroy() { ... NoteBus.unregisterResponseObserver(this); }} 4. 在模块的管理类中，将 业务 注册成为请求处理者。12345678910public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { NoteBusiness noteBusiness = new NoteBusiness(); noteBusiness.init(getApplicationContext()); NoteBus.registerRequestHandler(noteBusiness); ... }} 5. 在业务中异步处理各种请求。 期间可发送进度消息，最后可返回结果数据。业务须继承于 BaseBusiness。12345678910111213141516171819public class NoteBusiness extends BaseBusiness&lt;NoteBus&gt; implements INoteRequest { @Override public void queryList() { handleRequest((e) -&gt; { List&lt;NoteBean&gt; list = mDataBase.getList(null, null); ... sendMessage(e, new Result(NoteResultCode.PROGRESS, bean.getId())); ... return new Result(NoteResultCode.QUERY_LIST, list); }); } @Override public void insert(NoteBean bean) { handleRequest((e) -&gt; { ... }); } ...} ⭐ ViaBus 架构已在 Github 开源，欢迎 Star &amp; Fork ~Github : KunMinX / android-viabus-architecture 更多文章Android：四大架构的优缺点，你真的了解吗？Viabus - 年轻人的第一款架构Android：你还在等那个，手把手带你重构的人出现吗？","link":"/2018/09/25/Android：1分钟掌握 ViaBus 架构的使用/"},{"title":"Android：这是一个高级工程师的国庆充电规划","text":"前言前不久刚结束对 20 模块项目的第 3 轮重构，一路见证 MVC、MVP、Clean 的优缺点并形成自己的体会。 近期在总结工作经验的同时，开始写博客。 之所以将规划放出来，一来是总结的过程中已经形成底稿，不如和大家一块分享，各抒己见。二来粘贴布告，能有效督促自己执行。 Viabus 架构 的开源就是因为有一天，和同事聊着聊着说要开源，结果就真的就做了。 国庆规划由于 Viabus 对很多人来说，是个很陌生的东西，因此如果想让更多人享受到，“合理而快捷” 的开发体验，可不是一件简单的事。 对此我想的招是，先在网上找个文艺小清新的项目，重构，然后挂在 Github 项目页面) 下方，这样人们就愿意尝试，毕竟试错成本超级小嘛。 在项目重构前，我需要利用国庆七天做一些准备工作。 以上是我依据 “个人开发” 的顺序流程而罗列的技术堆栈。 做过个人开发的一定知道，最头疼的莫过于被一些非专业层面的事情打断。例如如何设计一个好看的界面，这个页面的视觉交互该如何如何。 如果这些事情一开始没有定好，那软件开发根本无从开始。因为如果没有一个好看的界面，你都不会相信这个软件能受人喜欢，首先自己就不相信、不喜欢。 再者，如果没有一个既定的界面设计，那么开发的过程中就会不断的斟酌，反反复复，消磨了开发的热情、拖延了进度。 因此想到的好招就是上述说的，重构市面上已有的产品。 软件的本质软件的本质是数据的交互。数据是 app 的灵魂。 因而除了那些工具类软件，多数软件只有和后台建立了连接，才能源源不断的拿到数据和层出不穷的变换着展示。 所以第一个要掌握的就是 抓包。 教程网上一搜一大把，链接我就不提供了。可以使用 Charles（Mac） Fiddler（Windows） 来完成抓包工作。 除此之外，过程中可能还要涉猎一番 http 协议和 TCPIP 体系结构。掌握它们的概念，都是会用的到的。 软件重构的目标软件的本质是数据的交互。无论是多么简单还是复杂的软件，都遵守这一定律。小到一个方法：输入参数，返回结果，大到一个业务，一个模块，输入配置，返回结果。都是一个道理。 那么软件重构的目标，就是将不符合软件本质定律开发的软件，推倒重来，依据该定律来开发。 在该定律的指导下，UI 和 业务 是完全分离的。UI 的职责仅限于请求数据和处理 UI 逻辑，业务的职责仅限于处理请求和返回结果。因此 UI 只负责 UI，它不需要知道业务是怎么准备数据的，业务只负责数据，它不需要 UI 在拿到数据后怎么使用怎么处理。 刚好符合设计模式的6大原则。 因此，进一步说，软件重构的目标， 一是使数据的交互标准化。底线是，数据配置和资源的存放位置，必须便于联想。数据名称的定义，必须规范化，不允许使用魔法值。 二是使数据的交互模式化。意思是，数据交互的双方职责明确、职责边界明确、独立自主、互不干涉。 为此第二步就是，查阅一下数据交互框架的源码，对设计模式在 android 中的广泛应用有所见证。 通用必用 Widget 的准备磨刀不误砍柴工，平日里就要总结、归类和封装你在项目中必然会用的到的控件。例如列表、菜单、对话框等等。这样在编写新项目时，不会被打断。 根据使用场景，我将控件分为以下四类： 1.展示类。是那些供展示，不可编辑的控件。例如引导页、信息展示页。 2.提示类。像吐司、对话框等等，及时提醒用户必要信息的手段。我们可以通过它们来增强软件的表现力，以获取用户的信任。 3.导航类。就是点击即可从此处跳转到别处的控件。例如列表、按钮等。 4.表单类。就是可以执行输入、勾选等表单操作。 总结以上就是国庆期间的规划： 1.寻找文艺小清新项目，抓包，温习http和TCPIP。 2.归类和整理通用必用控件，供后期不断封装。 3.查阅数据交互框架的源码，见证设计模式。 感谢你的阅读，欢迎点赞评论督促我完成！ 更多文章Github : KunMinX / android-viabus-architectureAndroid：四大架构的优缺点，你真的了解吗？Viabus - 年轻人的第一款架构Android：你还在等那个，手把手带你重构的人出现吗？","link":"/2018/09/30/Android：这是一个高级工程师的国庆充电规划/"},{"title":"Rx钥匙：为无聊而生的 Android 开发者工具","text":"很高兴和大家见面！ 缘于 4 月中旬，我在掘金发表的 《你用不惯 RxJava，只因缺了这把钥匙》 （以下简称 “Rx钥匙” ）。 原本目标只是给大家一把钥匙，方便大家意会 RxJava 操作符的本质，想不到在后台收到 40 多条留言。有的读者因为豁然开朗而喜出望外，不吝留下夸张的赞美；也有读者觉得意犹未尽，表达了对见证更多的愿望。 从留言中，我看到了热心网友们对 Rx钥匙 的期待 和 各自内心世界的丰富多彩，这些期待甚至远远超出了 Rx钥匙 本身，期望它是一把能够解决无聊、带给自己更多的 魔法棒。 再加上，我自己也因为 “拿 SQL 来隐喻操作符” 的那番见解，而心生灵感： 不如做一件史上最无聊的事吧 —— 像设计师一样将每个像素都抠到极致，像工程师一样将工程设计模式和原则应用到每一个功能的编写，用无聊的方式来对抗无聊 —— 这是一款为无聊而生的面向 Android 开发者的操作符练习工具。 Add Operators Output Code Clear Expressions 除了提供 “解决无聊” 这一最核心功能之外，你还可以从这个开源项目获得的内容包括： 整洁的代码风格和标准的资源命名规范。 基于前沿的、遵循关注点分离的 JetPack MVVM 架构。 使用 RxJava 和 lambda 表达式。 AndroidX 和 Material Design 2 的全面使用。 ConstraintLayout 约束布局的最佳实践。 为提升手机桌面的逼格做贡献，让知识与美观并存，即使从不打开。 绝不使用 Dagger，绝不使用奇技淫巧、编写艰深晦涩的代码。 长期更新。 如你所见，Rx钥匙的界面效果大体已经出来了，我的目标是，将首页先打磨好，这样 Rx钥匙 的 Apk 最快可能下周就能正式和大家见面了。 鉴于目前在 RxJava 表达式的书写上存有一些 “字符联想” 上的小问题，如果你对此十分熟悉，请不吝参与进来，这个项目会因为你的参与而变得更好！ 项目链接：https://github.com/KunMinX/RxJava2-Operators-Sample","link":"/2019/04/29/Rx钥匙：为无聊而生的 Android 开发者工具/"},{"title":"你用不惯 RxJava，只因缺了这把钥匙","text":"前言本文最初是为部门内部培训而准备的，但经过一番调研发现，同事们用不惯 RxJava，并不是因为网上介绍 “怎么用” 的教程不够多，恰恰是因为，一上来就急着发车的教程无数、却从未有过哪篇教程 舍得用几句话的功夫点破 RxJava 操作符究竟为何方神圣、我们为什么要用、为什么要那样用。 1234Observable.just(1, 3, 5, 7, 9) .map(i -&gt; i + 1) .filter(i -&gt; i &lt; 5) .subscribe(getObserve()); 事实上，在相当长的一段时间里，我也和大部分人一样，只知道使用 RxJava 来完成异步回调，至于那些操作符，则是能不用尽量不用，因为不知道葫芦里卖的什么药，看不懂、不会用。 因此，本文的初衷绝不是翻译官方文档、教大家怎么用，而是旨在帮助大家对 RxJava 操作符 完成感性上的认识。鉴于本次培训的效果还不错、同事们听了都说好，我便在 GitHub 开源了全套操作符示例代码（不要慌，链接文末已给出）。如果你在阅读本文后觉得恍然大悟，原来 RxJava 操作符是这么回事，那么我的愿望也就达到了。 编程语言包含多种编程范式我对操作符本质的顿悟，始于我对编程语言的理解。和你一样，我是做安卓开发，但有一天，我决定跳出 Java，从整个计算机科学的角度来学习和理解编程语言的本质，在这过程中，我接触了“编程范式”这个概念，了解到原来每个编程语言大都包含多种编程范式。 常见的编程范式有：命令式编程、声明式编程等。 以 Java 为例，咱们 Java 最主要的编程范式是命令式编程。命令式编程 即按顺序执行具体的命令，这些命令不仅交待了做什么，还详细交待了每一步怎么做。 SQL 也是种编程语言，是一种典型的声明式编程。声明式编程的特点是，只交待做什么，但无须交待怎么做。 操作符的本质是声明式编程下面回到我们最初的问题上来。你之所以用不惯 RxJava 操作符，是因为你习惯性地使用命令式编程思维 来理解实际上是声明式编程的操作符。学习操作符，就和你在大学里接受的 SQL 语句一样理所当然。 SQL 你是理解的，就是按一定的规则，向数据库中的数据声明你要做什么。 同理，RxJava 也是按一定的规则，向数据流声明你要做什么。 转换成代码，便成为以下这样。 1234Observable.just(1, 3, 5, 7, 9) .map(i -&gt; i + 1) .filter(i -&gt; i &lt; 5) .subscribe(getObserve()); 这样说，你理解了吗？ 全套操作符示例代码https://github.com/KunMinX/RxJava2-Operators-Sample","link":"/2019/04/18/你用不惯 RxJava，只因缺了这把钥匙/"},{"title":"大物始于小：我的 GitHub star 是如何在 5 天内从 0 飙至 666 的","text":"前言很高兴和大家见面！ 上周五我在掘金发表了 《真香警告：即使不用饿了么订餐，也请务必收藏好该库！》，文中主角 Linkage-RecyclerView 原本只是为 《RxJava魔法师》 这个项目的需求而存在的，没想到在各路读者的积极参与下，让一个本来默默无闻的项目，在内容发布的第三天，登陆 GitHub 今日趋势 Java 专区榜单前三，并在 5 天内做到 GitHub star 从 0 飙至 666。（不要慌，项目链接文末已给出） 在此我首先特别感谢热心读者的见证和参与。掘金社区、WanAndroid 读者对源码的认真阅读和交流，让我备受感动。 开源这个项目的初衷每个架构都有专属的用武之地开源这个项目的初衷有两个，一个是方便读者借助该项目深入理解，当我们为项目选择架构时，选材的依据是什么。 就我当前的认知来看，项目开发，无非就是顾及 “配置解耦” 和 “职责分离” 这两件事。 对于通用必用的控件库和组件库，我们可以将其抽取成模块，做成可供多个项目依赖的第三方库。第三方库的目标是让使用者无需了解内部逻辑、通过外部简单的配置即可轻松上手，因而第三方库适合使用 MVP 架构，来实现 “配置解耦”。 对于多人参与的主干工程，我们需要确保 UI 和 业务之间可以分工给不同的人协作，这就要求架构必须具备 “关注点分离（SoC）” 或 “职责分离（SoD）” 的特性。 因而我们可以在主干工程中采用目前主流的关注点分离架构 JetPack MVVM，或者由我自主设计并在公司项目重构中采用的职责分离的 VIABUS Architecture。 未雨绸缪方能在关键时刻拯救自己开源这个项目的另一个缘由是： 有些事我都已忘记，但我现在还记得，在一个晚上，同事阿左问我，今天怎么不开心。 我说在我的想象中，有一个开源库，与众不同最时尚，接入肯定棒，整个 GitHub 找遍所有的 Repo，都没有。他说将来会找到的，时间，时间，会给我答案。。 哈哈，开玩笑的。缘于，公司某个项目中的另一个需求：为多级联动表单动态绑定数据。 用过 Spinner 的读者都知道，原生的 Spinner 在 onSelectItem 回调中存在延迟的 bug，虽然延迟只有 100ms，但对于哼哧哼哧地装载、绑定、协调表单数据的多级联动表单来说，实在是致命的错误。 因而在那天晚上加班改需求的时候，我非常盼望着找到一款当下就可以使用的 PopupWindow + RecyclerView 实现的第三方 Spinner 开源库。 然而，现实却和我开了个大玩笑，我寻遍了 GitHub 仓库，尝试了若干个项目，都是随便糊弄两下、高度耦合的个人练手项目，这对于急着改需求的我来说，无异于火上浇油。 由于情况紧急，我选择求助于同在加班的阿左，没想到，阿左居然在项目闲时自己封装了一个 Spinner 库。 虽然一眼望去，Adapter 三方逻辑的解耦程度还有待提高，但这个库既然能独立存在、通过几行代码即可调用，对于彼时的我来说，就已经是最丰盛、最美的食物。 于是我毫不犹豫地将该库用在了项目上，在几经尝试后，表单初始化数据终于如愿地正常加载。 如何在 5 天内使 GitHub star 从 0 飙到 666最后总结一下大家都关心的，如何让自己的作品能被更多地访问、让 GitHub Star 数一路爬升： 即使忘了其他方法，也请务必记得这个不是方法的方法：———— 向用户提供价值。 什么是价值？人们对一件事物有需求，这件事因而有了价值。 人们有什么需求？人们面临着什么困境？这是每个想要服务于大众的人都要首先考虑明白的。 换言之，我们所做的每一件事，都务必精准地化解目标用户的痛点，唯有如此，才有机会在纷杂的信息中脱颖而出，让作品受到用户的青睐和珍视。 每个人服务的领域不同、目标用户也不同，因而用户痛点需要自己在日常生活中投入大量精力去思考和领悟，这也是为什么文章我一周最多只更新一篇的原因。 再者，就算是制作一款简单的作品，也请务必抱着一颗敬畏的心。在 Linkage-RecyclerView 开源的短短几天里，我累计提交了 49 次代码、多达 9k 行的代码变动。 用户不是傻子，代码是好是坏，一眼就能看出来。唯有一丝不苟地对待工程设计和编码，才有机会让用户感到确定和安心。 此外，酒香也怕巷子深。想让精心打磨的作品让更多的用户接触到，就要勇于在社交场合展示自己的价值。产品最终都是服务于人，务必多与用户沟通，让产品和个人品牌往更好的方向发展。 当然，口说无凭，以下贴上 别处看不到的、且大家喜闻乐见的 群聊学（chui）习（niu）交（ba）流（gua）截图： 考虑到我在技术社区发文，应以技术分享和经验交流为主。想目睹群聊现场的朋友，请移一步到我的同名公众号阅读原文~ GitHub 项目链接：https://github.com/KunMinX/Linkage-RecyclerView","link":"/2019/05/17/大物始于小：我的 GitHub star 是如何在 5 天内从 0 飙至 666 的/"},{"title":"这样理解，你也能在 30 秒内讲明白 TCP 三次握手","text":"前言某四年经验的同事，去一家包括老板在内总人数只有 13 人的创业团队，面试一份 移动端技术经理 的职位。开始聊得还挺好的，涉及的不外乎何时何地项目上解决了哪些用户痛点、开发过程中遇到过哪些问题、怎么看待和诊断遇到过的问题、有没有业余的开源项目等等。 毕竟四年老手，面试前也有些准备，轻松地就答复了前面这些疑问，只是没想到，面试官最后抛出这样一个问题，把同事给难住了：如何用 30 秒给新手讲明白 TCP 三次握手？ 技术经理的职责是解决认知困扰技术经理不同于刚毕业一两年的工程师，也不能和“主程”同日而语。技术经理的职责是，“为团队成员指明正确的方向、用最小的代价帮助团队快速成长”。 这句话看似难理解，其实归根结底是指，技术经理的首要工作是解决团队成员的认知困扰，包括在遇到研发问题时，能结合 背景知识 轻松定位到问题的实质，以及面对新技术和陌生领域时，能够结合背景知识迅速归类和深入浅出地给新手讲明技术的来由。 你的遭遇，也是共同普遍的遭遇换言之，如果交待任务时，上司只会“给个眼神你自己体会”， 或是遇到问题时，一言不合就发车、手把手带你怎么做、留下一旁观看的你一脸懵逼，而不是首先使用简练的语言将事情的缘由讲明白、然后引导你、鼓励你自己去完成，那这样的相处势必会让你感到自己很笨很囧。 然而，事情变成这样，并不全是你的错，你每天都要顶着压力、忙着完成搬砖的任务，深度思考的时间自然就少。与此同时，上司若是没能够履行自己的职责，而只是经验上十分娴熟，那他是无法真正帮你拨开迷雾、带你快速成长的。 下面回到最初的那个问题： 如何用 30 秒给新手讲明白 TCP 三次握手？首先，绝不可能引用某些书籍或某百科的说辞。本来新手就已经足够迷惑了，结果这些“权威”反倒乐此不疲地介绍表象、介绍怎么做，一言不合就 ACK=j+1、SYN+ACK，而绝口不提事情的本质、现象产生的缘由。 总之听不懂都怪新手自己，他们的世界观是完美而母庸质疑的。如果新手因为被蛊惑而被迫盲从，那正是他们想看到的。比起用技术改善生活，他们更热衷于拔高门槛或建立个人宗教。 好在这位同事除了经验娴熟，业余时间还有复盘的习惯，能够抛开“怎么做”的表象，去审视一件事它之所以存在，到底“是什么”、“为什么”。因此，借此机会我们和这位同事一起来审视一下，三次握手的本质到底是什么？引发它这么做的背景又是什么？ 三次握手的背景是通信双方“人在家中坐”如你所知，通信设备之所以存在，是因为有“远距离通信”的需要，否则你就站在我面前，我何须对着你讲电话呢？既然我与通信的另一方有一定的物理距离，并且既然我选择使用通信设施，那我就不可能 亲自护送信息到对方面前，我和对方都需要 原地不动地交由第三方送信使者来帮助我们来回传递信息。 因此，在相互寄送真正的信物之前，我们需要首先确认双方收发信件的能力是否正常，否则我寄出信物，路上遭遇车祸，或对方已搬家，那么我们便无法实现彼此的通信。并且前面也说了，“人在家中坐，不可亲自来”，我和对方各自坐在家里，怎么才能知道彼此之间能够正常收发信件呢？ 正是基于上述的背景，我们的前辈发明了三次握手 —— 用于“确认通信双方收发数据能力”的解决方案。 三次握手的本质是确认通信双方收发数据的能力首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。 于是他给我回信，我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。 然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。 这，就是三次握手，这样说，你理解了吗？ 全文完","link":"/2019/04/25/这样理解，你也能在 30 秒内讲明白 TCP 三次握手/"},{"title":"Android：四大架构的优缺点，你真的了解吗？","text":"前言你准备好了吗？本次列车开往 “重构” 之巅，时速 900km/s。风太大听不见，但我就是可以很简单很直的，给你讲述事物本质和解决方案！⚡ 项目常用架构比对以下，对常见的 MVC、MVP、Clean、AAC 架构做个比对。 首先，一张表格展示各架构的类冗余情况： 需求是，写三个页面，ListFragment、DetailFragment、PreviewFragment，每个页面至少用到 3个 Note 业务、3个 User 业务。问：上述架构分别需编写多少类？ 架构 涉及类 类总数 MVC Fragment:3个，Controller：3个，Model:2个 8个 MVP Fragment:3个，Presenter:3个，Model:3个，Contract:1个 10个 Clean Fragment:3个，ViewModel:3个，Usecase:18个，Model:3个 27个 AAC Fragment:3个，ViewModel:3个，Model:3个 9个 MVC 架构的缺陷 View、Controller、Model 相互依赖，造成代码耦合。 难以分工，难以将 View、Controller、Model 分给不同的人写。 难以维护，没有中间件接口做缓冲，难以替换底层的实现。 1234567891011121314151617181920212223242526272829303132public class NoteListFragment extends BaseFragment { ... public void refreshList() { new Thread(new Runnable() { @Override public void run() { //view 中直接依赖 model。那么 view 须等 model 编写好才能开工。 mNoteList = mDataManager.getNoteList(); mHandler.sendMessage(REFRESH_LIST, mNoteList); } }).start(); } private Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg) { case REFRESH_LIST: mAdapter.setList(mNoteList); mAdapter.notifyDataSetChanged(); break; default: } } }; ...} MVP 架构的特点与局限 MVP 架构的特点是 面向接口编程。在 View、Presenter、Model 之间分别用 中间件接口 做衔接，当有新的底层实现时，能够无缝替换。 此外，MVP 的 View 和 Model 并不相互依赖，因此可以说是对 View 和 Model 做了代码解耦。 1234567891011121314151617181920212223242526272829public class NoteListContract { interface INoteListView { void showDialog(String msg); void showTip(String tip); void refreshList(List&lt;NoteBean&gt; beans); } interface INoteListPresenter { void requestNotes(String type); void updateNotes(NoteBean... beans); void deleteNotes(NoteBean... beans); } interface INoteListModel { List&lt;NoteBean&gt; getNoteList(); int updateNote(NoteBean bean); int deleteNote(NoteBean bean); }} 但 MVP 架构有其局限性。按我的理解，MVP 设计的初衷是，“让天下没有难替换的 View 和 Model” 。该初衷背后所基于的假设是，“上层逻辑稳定，但底层实现更替频繁” 。在这个假设的引导下，Presenter 除了承担业务逻辑的责任，还越界接管了 UI逻辑，这使得 UI 和 业务发生了耦合。 如此，一旦 UI 需求变化，UI 和 业务的编写者都会受到牵连，占据 2 份甚至更多工时。 且由于 UI 编写者的“权力上缴”，使得在 UI 编写完成后 无法独立完成单元测试。（因为此处缺少了 UI 逻辑 —— 总不能为了测试，而背着 Presenter 自己另外写一波吧。所以除了那种“上层逻辑稳定”的组件，无论从哪个角度来看，用 MVP 来架构项目，都是不合适的） 123456789101112131415161718192021222324252627282930public class NoteListPresenter implements NoteListContract.INoteListPresenter { private NoteListContract.INoteListModel mDataManager; private NoteListContract.INoteListView mView; @Override public void requestNotes(String type) { Observable.create(new ObservableOnSubscribe&lt;List&lt;NoteBean&gt;&gt;() { @Override public void subscribe(ObservableEmitter&lt;List&lt;NoteBean&gt;&gt; e) throws Exception { List&lt;NoteBean&gt; noteBeans = mDataManager.getNoteList(); e.onNext(noteBeans); } }).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;List&lt;NoteBean&gt;&gt;() { @Override public void accept(List&lt;NoteBean&gt; beans) throws Exception { //presenter 直接干预了 UI 在拿到数据后做什么，使得职责上没有发生解耦。 //正常来说，解耦意味着，presenter 的职能边界仅限返回结果数据， //由 UI 来依据响应码处理 UI 逻辑。 mView.refreshList(beans); } }); } ...} Clean 架构的特点和不足 为解决 Presenter 职能边界不明确 的问题，在 Clean 架构中，业务逻辑的职能被转移到领域层，由 Usecase 专职管理。Presenter 则弱化为 ViewModel ，作为代理数据请求，和衔接数据回调的缓冲区。 Clean 架构的特点是 单向依赖、数据驱动编程。 View -&gt; ViewModel -&gt; Usecase -&gt; Model 。 View 对 ViewModel 的单向依赖，是通过 DataBinding 特性实现的。ViewModel 只负责代理数据请求，在 Usecase 处理完业务返回结果数据时，结果数据被赋值给可观察的 DataBinding 数据，而 View 则依据数据的变化而变化。 1234567891011121314151617181920212223242526272829public class NoteListViewModel { private ObservableList&lt;NoteBean&gt; mListObservable = new ObservableArrayList&lt;&gt;(); private void requestNotes(String type) { if (null == mRequestNotesUsecase) { mRequestNotesUsecase = new ProveListInitUseCase(); } mUseCaseHandler.execute(mRequestNotesUsecase, new RequestNotesUsecase.RequestValues(type), new UseCase.UseCaseCallback&lt;RequestNotesUsecase.ResponseValue&gt;() { @Override public void onSuccess(RequestNotesUsecase.ResponseValue response) { //viewModel 的可观察数据发生变化后，databinding 会自动更新 UI 展示。 mListObservable.clear(); mListObservable.addAll(response.getNotes()); } @Override public void onError() { } }); } ...} 但 Clean 架构也有不足：粒度太细 。一个 UseCase 受限于请求参数，因而只能处理一类请求。View 请求的数据包含几种类型，就至少需要准备几个 UseCase 。UseCase 是依据当前 View 对数据的需求量身定制的，因此 UseCase 的复用率极低，项目会因而急剧的增加类和重复代码。 12345678910111213141516171819202122232425262728293031323334public class RequestNotesUseCase extends UseCase&lt;RequestNotesUseCase.RequestValues, RequestNotesUseCase.ResponseValue&gt; { private DataManager mDataManager; @Override protected void executeUseCase(final RequestValues values) { List&lt;NoteBean&gt; noteBeans = mDataManager.getNotes(); ... getUseCaseCallback().onSuccess(new RequestNotesUseCase.ResponseValue(noteBeans)); } //每新建一个 UseCase 类，都需要手动为其配置 请求参数列表 和 响应参数列表。 public static final class RequestValues implements UseCase.RequestValues { private String type; public String getType() { return type; } public void setType(String type) { this.type = type; } } public static final class ResponseValue implements UseCase.ResponseValue { public List&lt;NoteBean&gt; mBeans; public ResponseValue(List&lt;NoteBean&gt; beans) { mBeans = beans; } }} AAC 架构的特点AAC 也是数据驱动编程。只不过它不依赖于 MVVM 特性，而是直接在 View 中写个观察者回调，以接收结果数据并处理 UI 逻辑。 123456789101112131415public class NoteListFragment extends BaseFragment { @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); viewModel.getNote().observe(this, new Observer&lt;NoteBean&gt;() { @Override public void onChanged(@Nullable NoteBean bean) { //update UI } }); } ...} 你完全可以将其理解为 B/S 架构：由 Web 前端向 Web 后端发送了数据请求，后端在处理完毕后响应结果数据给前端，前端再依据需求处理 UI 逻辑。等于说， AAC 将业务完全压到了 “数据仓库层”。 某“解耦分离”架构的由来及特点公司项目的第三轮重构采用的是 Clean 架构，而我在业余时间又设计了一款“实现 UI 和业务分离”的某架构，于是向主管申请了 1 周时间，利用“某架构”将 60 个类的核心模块重构了一遍。（不要慌，该架构已开源，文末链接给出）。 该架构属于“消息驱动编程”，即借助“总线”来转发数据的请求和响应，实现 UI 和 业务的分离。 不同于以往的架构，该架构明确界定了什么是 UI，什么是业务。 UI 的作用是视觉交互，UI 的职责范围仅限于请求数据和处理 UI 逻辑 。业务的作用是供应数据，业务的职责范围仅限于接收请求、处理数据、返回结果数据 。 你看，就像前后端分离一样，UI 和业务，可以分别交由不同的人分工合作： 1.独立自主。 谁先完成了，就可以先独立的单元测试一把。 2.可持续发展。 由于相互独立，人们可以在各自的领域里深耕。比如写业务的人： 第一轮，他可以简单的写写业务，目标是把数据给到位。 第二轮，他可以考虑改进业务逻辑、改进算法和数据结构，不仅将数据给到位，还优化了性能。 第三轮，他可以考虑安全性，将业务逻辑全部写进 C 层，这样反编译后除了 findViewById，啥 if else 也看不见，更别说篡改和破解了。 你看，解耦分离后，要想迭代和发展，就是这么轻松畅快。这要是放到代码耦合的项目中，是怎么也不敢想。 总结综上，本文介绍了 4 个架构以及它们的优缺点。在实际项目开发中，可根据项目规模的大小、项目上层逻辑的稳定程度，来选择最合适的架构。 看完这篇文章，如你觉得有所收获和启发，请不吝点赞，你的点赞就是对我最大的支持！ 更多访问1分钟掌握 ViaBus 架构的使用Viabus - 年轻人的第一款架构Android：你还在等那个，手把手带你重构的人出现吗？","link":"/2018/09/25/Android：四大架构的优缺点，你真的了解吗？/"},{"title":"真香警告：即使不用饿了么订餐，也请务必收藏好该库！","text":"由来LinkageRecyclerView 是一款基于 MVP 架构开发的二级联动列表控件。它是因 “RxJava 魔法师” 这个项目的需求而存在。 在最初寻遍了 GitHub 也没有找到合适的开源库（高度解耦、可远程依赖）之后，我决心研究参考现有开源项目关于二级联动的逻辑，并自己动手编写一个 高度解耦、轻松配置、可通过 Maven 仓库远程依赖 的真正的第三方库。 LinkageRecyclerView 的个性化配置十分简单，依托于 MVP 的 “配置解耦” 特性，使用者无需知道内部的实现细节，仅通过实现 Config 类即可完成功能的定制和扩展。 此外，在不设置自定义配置的情况下，LinkageRecyclerView 最少只需 一行代码即可运行起来。 RxMagic Eleme Linear Eleme Grid 目标LinkageRecyclerView 的目标是：一行代码即可接入二级联动列表。 除了一键接入而省去 99% 不必要的、复杂的、重复的工作外，你还可以从这个开源项目获得的内容包括： 整洁的代码风格和标准的资源命名规范。 MVP 架构在编写第三方库的最佳实践：使用者无需了解内部逻辑，通过实现接口即可轻松完成个性化配置。 优秀的代码分层和封装思想，在不做任何个性化配置的情况下，一行代码即可接入。 主体工程基于前沿的、遵循关注点分离的 JetPack MVVM 架构。 AndroidX 和 Material Design 2 的全面使用。 ConstraintLayout 约束布局的最佳实践。 绝不使用 Dagger，绝不使用奇技淫巧、编写艰深晦涩的代码。 如果你正在思考 如何为项目挑选合适的架构 的话，这个项目值得你参考！ 项目链接：https://github.com/KunMinX/LinkageRecyclerView 简单使用：1.在 build.gradle 中添加对该库的依赖。 1implementation 'com.kunminx.linkage:linkage-recyclerview:1.3.5' 2.依据默认的分组实体类（DefaultGroupedItem）的结构准备一串数据（以下以 JSON 为例）。 1234// DefaultGroupedItem.ItemInfo 包含三个字段：String title //（必填）二级选项的标题String group //（必填）二级选项所在分组的名称，要和对应的一级选项的标题相同String content //（选填）二级选项的内容 1234567891011121314151617181920212223242526[ { \"header\": \"优惠\", \"isHeader\": true }, { \"isHeader\": false, \"info\": { \"content\": \"好吃的食物，增肥神器，有求必应\", \"group\": \"优惠\", \"title\": \"全家桶\" } }, { \"header\": \"热卖\", \"isHeader\": true }, { \"isHeader\": false, \"info\": { \"content\": \"爆款热卖，月销超过 999 件\", \"group\": \"热卖\", \"title\": \"烤全翅\" } }] 3.在布局中引入 LinkageRecyclerView 。 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;com.kunminx.linkage.LinkageRecyclerView android:id=\"@+id/linkage\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt;&lt;/LinearLayout&gt; 4.在得到数据后，最少只需一行代码即可完成初始化。 1234List&lt;DefaultGroupedItem&gt; items = gson.fromJson(...);//一行代码完成初始化linkage.init(items); 注意：如使用 JSON，请在 ProGuard Rules 中为该实体类配置混淆白名单： 1-keep class com.kunminx.linkage.bean.** {*;} 个性化配置：该库为一级和二级 Adapter 分别准备了 Config 接口（ILevelPrimaryAdapterConfig 和 ILevelSecondaryAdapterConfig），自定义配置时，即是去实现这两个接口，来取代默认的配置。 之所以设置成接口的形式，而非 Builder 的形式，是因为二级联动列表内部的联动逻辑需要指明关键的控件。接口相比 Builder 具有强制性，能够让使用者一目了然必须配置的内容，故而采用接口，通过 MVP 架构的方式来编写该库。 关于个性化配置，具体可以参考我在 ElemeGroupedItem 和 SwitchSampleFragment 中编写的案例： Step1：根据需求扩展实体类你需要根据需求，在 BaseGroupedItem 的基础上扩展分组实体类，具体的办法是，编写一个实体类，该实体类须继承于 BaseGroupedItem；该实体类的内部类 ItemInfo 也须继承于 BaseGroupedItem.ItemInfo。 以 Eleme 分组实体类为例，扩充 content、imgUrl、cost 三个字段： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ElemeGroupedItem extends BaseGroupedItem&lt;ElemeGroupedItem.ItemInfo&gt; { public ElemeGroupedItem(boolean isHeader, String header) { super(isHeader, header); } public ElemeGroupedItem(ItemInfo item) { super(item); } public static class ItemInfo extends BaseGroupedItem.ItemInfo { private String content; private String imgUrl; private String cost; public ItemInfo(String title, String group, String content) { super(title, group); this.content = content; } public ItemInfo(String title, String group, String content, String imgUrl) { this(title, group, content); this.imgUrl = imgUrl; } public ItemInfo(String title, String group, String content, String imgUrl, String cost) { this(title, group, content, imgUrl); this.cost = cost; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public String getImgUrl() { return imgUrl; } public void setImgUrl(String imgUrl) { this.imgUrl = imgUrl; } public String getCost() { return cost; } public void setCost(String cost) { this.cost = cost; } }} 注意：如使用 JSON，请在 ProGuard Rules 中为该实体类配置混淆白名单。 Step2：实现接口，完成自定义配置在装载数据和实现自定义配置时，泛型框中须指明你编写的实体类，注意 List&lt;ElemeLinkageItem&gt;，以及 new ILevelSecondaryAdapterConfig&lt;ElemeLinkageItem.ItemInfo&gt;() 这两处。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101private void initLinkageDatas(LinkageRecyclerView linkage) { Gson gson = new Gson(); List&lt;ElemeGroupedItem&gt; items = gson.fromJson(...); linkage.init(items, new ILevelPrimaryAdapterConfig() { private Context mContext; public void setContext(Context context) { mContext = context; } @Override public int getLayoutId() { return R.layout.default_adapter_linkage_level_primary; } @Override public int getGroupTitleViewId() { return R.id.tv_group; } @Override public int getRootViewId() { return R.id.layout_group; } @Override public void onBindViewHolder( LinkageLevelPrimaryAdapter.LevelPrimaryViewHolder holder, String title, int position) { ((TextView) holder.mGroupTitle).setText(title); } @Override public void onItemSelected(boolean selected, TextView itemView) { itemView.setBackgroundColor(mContext.getResources().getColor(selected ? com.kunminx.linkage.R.color.colorLightBlue : com.kunminx.linkage.R.color.colorWhite)); itemView.setTextColor(ContextCompat.getColor(mContext, selected ? com.kunminx.linkage.R.color.colorWhite : com.kunminx.linkage.R.color.colorGray)); } }, new ILevelSecondaryAdapterConfig&lt;ElemeGroupedItem.ItemInfo&gt;() { private Context mContext; public void setContext(Context context) { mContext = context; } @Override public int getGridLayoutId() { return R.layout.adapter_eleme_secondary_grid; } @Override public int getLinearLayoutId() { return R.layout.adapter_eleme_secondary_linear; } @Override public int getHeaderLayoutId() { return R.layout.default_adapter_linkage_level_secondary_header; } @Override public int getSpanCountOfGridMode() { return 2; } @Override public void onBindViewHolder( LevelSecondaryViewHolder holder, BaseGroupedItem&lt;ElemeGroupedItem.ItemInfo&gt; item, int position) { ((TextView) holder.getView(R.id.iv_goods_name)) .setText(item.info.getTitle()); Glide.with(mContext).load(item.info.getImgUrl()) .into((ImageView) holder.getView(R.id.iv_goods_img)); holder.getView(R.id.iv_goods_item).setOnClickListener(v -&gt; { //TODO }); holder.getView(R.id.iv_goods_add).setOnClickListener(v -&gt; { //TODO }); } @Override public void onBindHeaderViewHolder( LevelSecondaryHeaderViewHolder holder, BaseGroupedItem&lt;ElemeGroupedItem.ItemInfo&gt; item, int position) { //TODO } });} Thanks tomaterial-components-android AndroidX My PagesEmail：kunminx@gmail.com Home：KunMinX 的个人博客 Juejin：KunMinX 在掘金 KunMinX’s WeChat Public Account（微信公众号）： License12345678910111213Copyright 2018-2019 KunMinXLicensed under the Apache License, Version 2.0 (the &quot;License&quot;);you may not use this file except in compliance with the License.You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an &quot;AS IS&quot; BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.","link":"/2019/05/10/真香警告：即使不用饿了么，也请不要错过这个库！/"},{"title":"Android：你还在等那个，手把手带你重构的人出现吗？","text":"前言高能预警：本文有一点长，建议收藏后再看。 以下你就可以看到，一位单枪匹马的帅哥，是如何以一己之力，重构整座“屎山”的。 这位帅哥一直在徘徊，本文到底该写给谁看？是只在乎写功能的码农吗？不了不了，码农若真的有心提升代码质量，就不会在项目中丧心病狂的堆积屎山。 于是干脆写写重构心得、分享重构思路，让那些有意识在这方面有所提升的帅哥美女们，少走些弯路！ 在此首先感谢主管的信任与支持。本次重构中，帅哥在部门内部兜售并率先使用某架构，5 天内完成 60 个类的核心模块的重构。（不要慌，架构已在 GitHub 开源，文末链接给出。） 以下正文。 代码是如何越写越烂的？你是否经常听同事自嘲，“开始还想好好写，不知怎滴，后面越写越烂”？ 代码越写越烂，果真是个没有端倪、无法干预的魔咒玄学吗？ 让我们来快速浏览一下 重构前 项目里的代码是怎么写的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376protected void initView() { PagerAdapter pagerAdapter = new PagerAdapter(); viewPagerFix.setOffscreenPageLimit(4); viewPagerFix.setAdapter(pagerAdapter); mFragmentBinding.tabLayout.setTabData(pagerAdapter.titles); mFragmentBinding.tabLayout.setOnTabSelectListener(new OnTabSelectListener() { @Override public void onTabSelect(int position) { viewPagerFix.setCurrentItem(position); } @Override public void onTabReselect(int position) { } }); viewPagerFix.addOnPageChangeListener(new ViewPagerFix.OnPageChangeListener() { @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) { KeyboardUtils.hideSoftInput(getActivity()); } @Override public void onPageSelected(int position) { mFragmentBinding.tabLayout.setCurrentTab(position); if (mViewModel.getXXXDetailTouchManager().isZZBG()) { zzbgPageSelected(position); } else if (mViewModel.getXXXDetailTouchManager().isYBJZ()) { switch (position) { case 0: case 1: mViewModel.removeAllArrows(); if (mAttachmentFragment != null) { mAttachmentFragment.hideClickHighLight(ALBUM_ALL); } break; case 2: if (mAttachmentFragment != null) { mAttachmentFragment.initAttachTitle(); } mViewModel.showAllArrows(); break; default: break; } } else { switch (position) { case 0: case 1: case 2: mViewModel.removeAllArrows(); //hideBottomLayout(); if (mAttachmentFragment != null) { mAttachmentFragment.hideClickHighLight(ALBUM_ALL); } break; case 3: if (mAttachmentFragment != null) { mAttachmentFragment.initAttachTitle(); } mViewModel.showAllArrows(); break; default: break; } } } @Override public void onPageScrollStateChanged(int state) { } }); viewPagerFix.setCurrentItem(0); mFragmentBinding.headContainer.getTitleView().setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (mViewModel.getXXXDetailTouchManager().isZZBG()) { return; } mViewModel.changeWyhcrwMajorState(); EventBus.getDefault().post(new RefreshItemEventBus( mViewModel.getXXXDetailTouchManager().getCurrentWyhcrw())); } }); } private void zzbgPageSelected(int position) { if (mScreenNum == 3) { switch (position) { case 0: case 1: mViewModel.removeAllArrows(); if (mAttachmentFragment != null) { mAttachmentFragment.hideClickHighLight(ALBUM_ALL); } break; case 2: mViewModel.showAllArrows(); break; default: break; } } else { switch (position) { case 0: mViewModel.removeAllArrows(); if (mAttachmentFragment != null) { mAttachmentFragment.hideClickHighLight(ALBUM_ALL); } break; case 1: mViewModel.showAllArrows(); break; default: break; } } ; } /** * viewPager适配器 */ private class PagerAdapter extends FragmentPagerAdapter { String[] titles; PagerAdapter() { super(getChildFragmentManager()); if (mViewModel.getXXXDetailTouchManager().isZZBG()) { if (mScreenNum == 3) { titles = getResources().getStringArray(R.array.XXX_detail_tabs_for_no_tbjt); } else { titles = getResources().getStringArray(R.array.XXX_detail_tabs_for_zzbg); } } else if (mViewModel.getXXXDetailTouchManager().isYBJZ()) { titles = getResources().getStringArray(R.array.XXX_detail_tabs_for_ybjz); } else { titles = getResources().getStringArray(R.array.XXX_detail_tabs); } } @Override public Fragment getItem(int position) { if (mViewModel.getXXXDetailTouchManager().isZZBG()) { return zzbgGetItem(position); } else if (mViewModel.getXXXDetailTouchManager().isYBJZ()) { switch (position) { case 0: if (mXXXTuBanPicFragment == null) { mXXXTuBanPicFragment = XXXTuBanPicFragment.newInstance( mViewModel.getUniqueCode(), mViewModel.getXXXTouchManger() ); } return mXXXTuBanPicFragment; case 1: if (mRecordFragment == null) { mRecordFragment = XXXRecordFragment.newInstance(mViewModel.getXXXDetailTouchManager()); } return mRecordFragment; default: if (mAttachmentFragment == null) { mAttachmentFragment = XXXAttachmentFragment.newInstance( mViewModel.getAttachments(), mViewModel.getOriginalAttachments(), mViewModel.getUniqueCode(), mViewModel.getXXXTouchManger(), XXXDetailFragment.this ); } return mAttachmentFragment; } } else { switch (position) { case 0: if (mXXXTuBanPicFragment == null) { mXXXTuBanPicFragment = XXXTuBanPicFragment.newInstance( mViewModel.getUniqueCode(), mViewModel.getXXXTouchManger() ); } return mXXXTuBanPicFragment; case 1: if (mAttributeFragment == null) { mAttributeFragment = XXXAttributeFragment.newInstance( mViewModel.getUniqueCode(), mViewModel.getXXXTouchManger() ); } return mAttributeFragment; case 2: if (mRecordFragment == null) { mRecordFragment = XXXRecordFragment.newInstance(mViewModel.getXXXDetailTouchManager()); } return mRecordFragment; default: if (mAttachmentFragment == null) { mAttachmentFragment = XXXAttachmentFragment.newInstance( mViewModel.getAttachments(), mViewModel.getOriginalAttachments(), mViewModel.getUniqueCode(), mViewModel.getXXXTouchManger(), XXXDetailFragment.this ); } return mAttachmentFragment; } } } private Fragment zzbgGetItem(int position) { if (mScreenNum == 3) { switch (position) { case 0: if (mAttributeFragment == null) { mAttributeFragment = XXXAttributeFragment.newInstance( mViewModel.getUniqueCode(), mViewModel.getXXXTouchManger() ); } return mAttributeFragment; case 1: if (mRecordFragment == null) { mRecordFragment = XXXRecordFragment.newInstance( mViewModel.getXXXDetailTouchManager()); } return mRecordFragment; default: if (mAttachmentFragment == null) { mAttachmentFragment = XXXAttachmentFragment.newInstance( mViewModel.getAttachments(), mViewModel.getOriginalAttachments(), mViewModel.getUniqueCode(), mViewModel.getXXXTouchManger(), XXXDetailFragment.this ); } return mAttachmentFragment; } } else { switch (position) { case 0: if (mRecordFragment == null) { mRecordFragment = XXXRecordFragment.newInstance( mViewModel.getXXXDetailTouchManager()); } return mRecordFragment; default: if (mAttachmentFragment == null) { mAttachmentFragment = XXXAttachmentFragment.newInstance( mViewModel.getAttachments(), mViewModel.getOriginalAttachments(), mViewModel.getUniqueCode(), mViewModel.getXXXTouchManger(), XXXDetailFragment.this ); } return mAttachmentFragment; } } } @Override public Object instantiateItem(ViewGroup container, int position) { Object object = super.instantiateItem(container, position); if (mViewModel.getXXXDetailTouchManager().isZZBG()) { if (mScreenNum == 3) { switch (position) { case 0: mAttributeFragment = (XXXAttributeFragment) object; break; case 1: mRecordFragment = (XXXRecordFragment) object; break; default: mAttachmentFragment = (XXXAttachmentFragment) object; break; } } else { switch (position) { case 0: mRecordFragment = (XXXRecordFragment) object; break; default: mAttachmentFragment = (XXXAttachmentFragment) object; break; } } return object; } else if (mViewModel.getXXXDetailTouchManager().isYBJZ()) { switch (position) { case 0: mXXXTuBanPicFragment = (XXXTuBanPicFragment) object; break; case 1: mRecordFragment = (XXXRecordFragment) object; break; default: mAttachmentFragment = (XXXAttachmentFragment) object; break; } return object; } else { switch (position) { case 0: mXXXTuBanPicFragment = (XXXTuBanPicFragment) object; break; case 1: mAttributeFragment = (XXXAttributeFragment) object; break; case 2: mRecordFragment = (XXXRecordFragment) object; break; default: mAttachmentFragment = (XXXAttachmentFragment) object; break; } return object; } } @Override public int getCount() { if (mViewModel != null) { if (mViewModel.getXXXDetailTouchManager().isZZBG()) { if (mScreenNum == 3) { return 3; } return 2; } if (mViewModel.getXXXDetailTouchManager().isYBJZ()) { return 3; } else { return 4; } } return 0; } } （为保护隐私，模块类名已替换为“XXX”） 可以看到，该主页目前服务于 3 个地区，每个地区对子页面的展示都有定制需求。 if else switch if else switch，只在乎功能实现的码农就是这么写的。 一个地区 50 行，那要是 10 个地区呢？公司领导放话要支持全国 100 个乡镇地区！那 100 个地区呢？？？ 抽象，顺应的是“开闭原则”这是一帮对“抽象”无感的码农。 他们听到“抽象”，就像不爱锻炼的我听到父母、朋友劝我“健身”一样被动。（笑） 正如我并不真的理解健身的意义所在，他们也当抽象是“耳边风”。 “100 个地区”这种，天然的就是用工厂模式来抽象和定制，这原本是一目了然、毫无疑问的事。 重构后的代码，主页抬头特意标注了警告。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/ * 友情提示：本类涂有防腐药品，切勿触碰，切勿触碰，切勿触碰！ * &lt;p&gt; * 地区定制功能，包括特色的布局等，请继承于 AbstractDetailChildFragmentManager 单独编写！ */public class XXXDetailFragment extends BaseFragment implements IResponse { protected void initView() { initViewPagerManager(); PagerAdapter pagerAdapter = new PagerAdapter(); viewPagerFix.setOffscreenPageLimit(4); viewPagerFix.setAdapter(pagerAdapter); mFragmentBinding.tabLayout.setTabData(pagerAdapter.titles); mFragmentBinding.tabLayout.setOnTabSelectListener(new OnTabSelectListener() { @Override public void onTabSelect(int position) { viewPagerFix.setCurrentItem(position); } @Override public void onTabReselect(int position) { } }); viewPagerFix.addOnPageChangeListener(new ViewPagerFix.OnPageChangeListener() { @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) { KeyboardUtils.hideSoftInput(getActivity()); } @Override public void onPageSelected(int position) { mFragmentBinding.tabLayout.setCurrentTab(position); mDetailChildFragmentManager.onPageSelected(position); } @Override public void onPageScrollStateChanged(int state) { } }); } /** * viewPager适配器 */ private class PagerAdapter extends FragmentPagerAdapter { String[] titles; PagerAdapter() { super(getChildFragmentManager()); titles = mDetailChildFragmentManager.getTitles(); } @Override public Fragment getItem(int position) { return mDetailChildFragmentManager.getItem(position); } @Override public Object instantiateItem(ViewGroup container, int position) { Object object = super.instantiateItem(container, position); return mDetailChildFragmentManager.instantiateItem(container, position, object); } @Override public int getCount() { return mDetailChildFragmentManager.getCount(); } }} 代码是如何剪不断理还乱的？听说过“代码耦合”和“解耦”的人很多，但真正理解这是怎么一回事的，恐怕只有你 ~ 因为哪怕你不知，你也即将见证一位帅哥如何手把手带你解耦 ~ 我们先来看下重构前的代码！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public interface XXXListNavigator { void updateRecyclerView(); void showProgressDialog(); void dismissProgressDialog(); void updateListView(); void updateLayerWrapperList(List&lt;LayerWrapper&gt; list); boolean isAnimationFinish(); void resetCount();}public class XXXListViewModel extends BaseViewModel { public void multiAddOrRemove(ArrayList&lt;String&gt; bsms, boolean isAdd) { if (null != mNavigator) { mNavigator.showProgressDialog(); } if (null == mMultiAddOrRemoveUseCase) { mMultiAddOrRemoveUseCase = new MultiAddOrRemoveUseCase(); } mUseCaseHandler.execute(mMultiAddOrRemoveUseCase, new MultiAddOrRemoveUseCase.RequestValues(isAdd, bsms, mLayerWrapperObservableField.get()), new UseCase.UseCaseCallback&lt;MultiAddOrRemoveUseCase.ResponseValue&gt;() { @Override public void onSuccess(MultiAddOrRemoveUseCase.ResponseValue response) { ToastUtils.showShort(getApplicationContext(), &quot;操作成功&quot;); clearData(); loadData(true, true); if (null != mNavigator) { mNavigator.dismissProgressDialog(); } } @Override public void onError() { ToastUtils.showShort(getApplicationContext(), &quot;操作失败&quot;); if (null != mNavigator) { mNavigator.dismissProgressDialog(); } } }); }} 可以看到，UI 过度暴露了“处理 UI 逻辑所依赖的过程 API”，并在业务中直接干预了 UI 逻辑，这是典型的 MVP 写法，这造成了耦合。一旦 UI 的需求有变动，View 和 Presenter 的编写者都会受到牵连。 而且，职责过多造成了依赖过多，这个 Presenter 会因为过多的依赖，而越写越臃肿：受“破窗效应”的驱使，别的码农会因为此处已经有某个依赖，而不假思索的接着往下写。 到底怎样才算解耦所谓解耦，是符合工程设计、符合设计模式原则的编码。 解耦的本质，我只说一遍： 职责边界明确，职责边界明确，职责边界明确。 符合单一职责原则：UI 的职责仅限于“展示”，也就是发送请求、处理 UI 逻辑。业务的职责仅限于“提供数据”，也就是接收请求、处理业务逻辑、响应结果数据。 符合依赖倒置原则、最小知识原则：UI 不需要知道数据是经过怎样的周转得来的，它只需发送请求，并在拿到结果数据后，自己内部消化 UI 逻辑。业务只需处理数据并响应数据给 UI，它不需要知道 UI 会怎样使用数据，更无权干预。 综上，无论是 UI 还是业务，都不应过度暴露内部逻辑 API 而受控于人，它们应只暴露请求 API，来响应外部的请求。过程逻辑应只在自己内部独立消化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class XXXListBusinessProxy extends BaseBusiness&lt;XXXBus&gt; implements IXXXListFragmentRequest { @Override public void multiAddOrRemove(final XXXListDTO dto) { handleRequest((e) -&gt; { ... if (TextUtils.isEmpty(existBsms)) { sendMessage(e, new Result(XXXDataResultCode.XXX_LIST_FRAGMENT_MULTI_ADD_OR_REMOVE, false)); } else { wyhcJgDBManager.insertAllTaskOfMine(existBsms, layersConfig); sendMessage(e, new Result(XXXDataResultCode.XXX_LIST_FRAGMENT_MULTI_ADD_OR_REMOVE, true)); } return null; }); } @Override public void refreshPatternOfXXXList(final XXXListDTO dto) { handleRequest((e) -&gt; { ... count.setMyXXXCount(wyhcJgDBManager.getMyXXXPatternCount()); return new Result(XXXDataResultCode.XXX_LIST_FRAGMENT_REFRESH_COUNT, count); }); } @Override public void changeXXXPatternOfMine(final XXXListDTO dto) { handleRequest((e) -&gt; { if (toMine) { ... } else { ... sendMessage(e, new Result(XXXDataResultCode.XXX_LIST_FRAGMENT_GET_ALL_PATTERN_OF_MINE, count)); } return null; }); }}public class XXXListFragment extends BaseFragment implements IResponse { XXXBus.XXX().queryList(mDto); XXXBus.XXX().multiAddOrRemove(mDto); XXXBus.XXX().queryPattern(mDto); ... @Override public void onResult(Result testResult) { String code = (String) testResult.getResultCode(); switch (code) { case XXXDataResultCode.XXX_LIST_FRAGMENT_REFRESH_LIST: updateRecyclerView((List&lt;Wyhcrw&gt;) testResult.getResultObject()); if (isNeedUpdateCount()) { ... } else { finishLoading(); } break; case XXXDataResultCode.XXX_LIST_FRAGMENT_MULTI_ADD_OR_REMOVE: if ((boolean) testResult.getResultObject()) { loadData(true, true); } else { ToastUtils.showShort(getContext(), &quot;操作失败&quot;); } dismissProgressDialog(); break; case XXXDataResultCode.XXX_LIST_FRAGMENT_REFRESH_PATTERN: ... break; default: } }} 解耦有什么好处？解耦的好处，福特最有话语权。 100 多年前，福特发明了世界上第一条流水线，让工人职责边界明确，从而得以分工和专注各自领域。 原先装配一辆车需 700 小时，通过流水线分工后，平均一辆 12.5 小时，这使得生产效率提升了近 60 倍！ 软件工程同理。 由于 UI 和业务职责边界明确，且相互通过接口通信，使得 UI 和业务的编写者能够真正的分工。 写 UI 的人，不会被业务的编写打断，他可以一气呵成的写自己的 UI。写业务的人，同样不会被打断，他可以专注于业务逻辑、数据结构和算法的优化。 写 UI 和写业务的人，都可以自己实现接口，去独立的完成单元测试，完全不必依赖和等候对方的实现。 最后，在职责边界明确的情况下，UI 就算写 100 个 UI 逻辑，那也是 UI，业务就算写 100 个业务，那也是业务，纯种，所以不会杂乱，何况我们还可以借助“接口隔离原则”继续往下分工！ … 总结综上，本文介绍了两个重构思路：1.顺应开闭原则，对定制化功能进行抽象。2.顺应单一职责、最小知识、依赖倒置原则，让职责边界明确，防止代码耦合。 看完这篇文章，如你觉得有所收获和启发，请不吝点赞，你的点赞就是对我最大的支持！ 本次项目重构用到的，符合设计模式原则的 viabus 架构，已在 GitHub 开源：GitHub：KunMinX/android-viabus-architecture 更多文章Android：四大架构的优缺点，你真的了解吗？Viabus - 年轻人的第一款架构wiki - 1分钟掌握 ViaBus 架构的使用https://www.jianshu.com/p/6545767d3e54)","link":"/2018/10/21/Android：你还在等那个，手把手带你重构的人出现吗？/"}],"tags":[{"name":"ViaBus","slug":"ViaBus","link":"/tags/ViaBus/"},{"name":"项目推荐","slug":"项目推荐","link":"/tags/项目推荐/"},{"name":"RxJava","slug":"RxJava","link":"/tags/RxJava/"},{"name":"深度思考","slug":"深度思考","link":"/tags/深度思考/"},{"name":"Linkage","slug":"Linkage","link":"/tags/Linkage/"},{"name":"RecyclerView","slug":"RecyclerView","link":"/tags/RecyclerView/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"AAC","slug":"AAC","link":"/tags/AAC/"}],"categories":[{"name":"Architecture","slug":"Architecture","link":"/categories/Architecture/"},{"name":"RxJava","slug":"RxJava","link":"/categories/RxJava/"},{"name":"Library","slug":"Library","link":"/categories/Library/"},{"name":"Web","slug":"Web","link":"/categories/Web/"}]}